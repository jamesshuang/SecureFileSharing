## Trust Model
For this phase of the project, we expand the role of adversarial behavior to include partial leakage of Group Server information. Moreover, we consider an environment in which some clients might attempt to subvert productivity of other users in the system.
- __Group Server__ The group server is still mostly trusted. However, in this phase of the project, we assume that through carelessness or malicious behavior, the group server administrator might leak the User List to unauthorized parties. The group server will still enforce proper authentication of connecting clients, as well as constraints of user and group creation, deletion, and management.
- __File Server__ The file server in this phase is, as in previous phases, largely untrusted. It is assumed to leak files to unauthorized users, as well as to fail to enforce proper constraints on file access, modification, and deletion.
- __Clients__ Clients in this phase are assumed to be actively attempting to subvert the system. This includes all previous threats from clients of previous phases, as well as attempts by individual clients to make use of the system unavailable to other users. In addition, there are malicious clients trying to gain access to the system by attempting to uncover user passwords.
- __Other Parties__ As in the previous phase, all traffic in the system is assumed to be actively monitored, recorded, and/or modified by an active adversary.


##Threats to Protect Against
In consideration of the expanded threat model presented above, we will address the following specific threats for this phase of the project. Each of these threats concerns either the privacy of users and their uses of the system or the availability of the system to legitimate users.

###T8 Leaked password list
In our current implementation, the UserList.bin file is not encrypted at all. If an adversary gains access to the list, through a leak, they would be able to access the hashed password of any user (as long as they know the user account exists). From there, an adversary would be able to brute force search the keyspace until a match is found. Once an adversary gains access to a user’s password, they would have the ability to login as the user and thus gain access to their files and group information.

In order to execute an attack against the current system, an adversary would need to gain access to the group server’s UserList.bin file, which is currently unencrypted. Next the adversary needs to create a UserList object from the UserList.bin file. Assuming the adversary knows the username of the person they are trying to impersonate, they can retrieve the hashed password of the person from the UserList object. From there, the adversary can brute force search the keyspace, which is by default a String of length 8 that can include all digits and all upper/lowercase letters. In order to check if the guessed password is correct, the generated password is hashed with SHA-256. The resulting hash is then compared with the hash retrieved from the UserList.bin file, and if the hashes match, the password has been cracked. It may take a few hours to brute force the keyspace, however this brute force attack can still be carried out in a reasonable amount of time. 

###T9 Spam file creation
After connecting via legitimate means to a file server, a malicious client might attempt to create hundreds or thousands of empty files with common names and extensions. In doing so, the malicious client can learn indirectly of the existence of files on the server, even those to which the adversary does not have access, by monitoring which upload requests return a FILE_EXISTS error code. Moreover, by filling the shared_files directory with useless files, the malicious client can effectively prevent legitimate users from uploading files with useful and/or common names, as well as potentially slowing down file server operations by bloating the file list. Since many companies have file naming policies, and average users often name files in highly predictable ways, this attack could be highly targeted in its garbage file naming.

###T10 Online password attack
A single malicious client could, in the current implementation of our application, launch an online password attack against the group server. Although the search space for the passwords is large, and offline attacks are prevented by our use of EKE, the group server does not prevent repeated attempts to authenticate. In launching such an attack, an adversary could both work toward cracking a user password as well as cause a limited denial of service (other more effective DoS attacks are still possible), since the group server must begin an encrypted Diffie-Hellman exchange for each attempt of an authenticating client. This attack assumes that the adversary knows the existence of the user account they are trying to gain access to.

## Threat Prevention Mechanisms
###T8 Leaked password list
In order to protect against this threat, we will encrypt the UserList.bin file with a 256-bit key using AES/CBC/PCKS5Padding. Specifically, our UserList object is stored in a SealedObject that is encrypted with a cipher using our 256-bit AES key. This key is initialized when the UserList.bin file is first created (i.e. the first time our file sharing system is used). The key will then be stored on the group server as a file called UserListKey.bin. Assuming that only our UserList.bin file gets leaked and that our group server is still secure, an adversary would not have access to the list since it is encrypted with a key that the adversary cannot access. When the group server is run, the group server will decrypt UserList.bin with the key (UserListKey.bin) that is stored on the group server, thus ensuring that only the group server has access to the UserList object.

###T9 Spam file creation
To prevent a malicious client from creating unlimited files in a single shared_files directory, which will prevent other users from uploading legitimate files of the same name, we will implement in this phase a one-directory-per-group policy, which separates the namespace of different groups’ files. By doing so, each group can have files of the same name, and a malicious user would have to be in the same group as the group he wants to attack (which we deem unlikely, since a group owner would not reasonably add a malicious user to a sensitive group in the first place). Thus, when multiple groups exist in  the system, each will be segregated into its own storage area on the file server. This allows a single file server to serve both commercial and personal users at once, for instance, without the risk of the personal users interfering negatively with the commercial users’ needs.

###T10 Online password attack
To limit the ability of an adversary to launch an online password attack against the group server, assuming a single point of origin (as opposed to a distributed attack), we implement a client IP address-based blacklisting functionality. The group server tracks failed authentication attempts and their originating IP address, and if the client fails authentication beyond an administrator-configured threshold, the group server places the ill-behaved client on a blacklist for a configurable amount of time. Any repeated attempts of the client to connect to the group server after being blacklisted will result in a denied connection as well as the resetting of the blacklist timer.

For the purposes of this phase, we have set the configuration options as follows: 5 failed attempts from a single source IP in under 5 minutes will cause the group server to black-list the client for a 5 minute period. We chose this value as a reasonable trade-off between usability (a user is unlikely to get their own password wrong five times in a row) and security (being able to guess only one password per minute on average reduces the effectiveness of an online attack to near negligible, as even an 8-random-character password of alphanumerics, as used by default in the system, would require 1.02 * 10^8 years to crack).

##Concluding notes
By this phase of the project, our system is largely resistant to bad behavior on the part of the network (e.g., envelope tampering/corruption), the file server (e.g., file leakage and/or modification, token theft, server impersonation), and clients (e.g., token tampering, user impersonation). Thus, coming up with new threats required both imaginative thinking (getting in the mind of an adversary) as well as expanding our threat model. In particular, our group server has, until now, been entirely trusted, both in terms of integrity of behavior and in performance. 

Two of our new threats for this phase involve expanding the threat definition relative to the group server; however, to prevent having to completely change the system architecture, we had to be somewhat conservative in this process. Namely, opening the possibility of unlimited group server compromise and file leakage would invalidate all of our assumptions to this point, so we described instead a model in which a careless or malicious administrator leaks only the user list file, which acts similarly in fashion to /etc/passwd on an old *NIX system, with password hashes stored in plaintext alongside user names. Moreover, we considered the possibility of a specific attack from single determined clients to subvert the user authentication process, which required a mechanism for identifying and prohibiting suspicious client behavior.

The final threat we consider is indirect compromise of service on a file server. For this threat we considered a much less obvious attack that, instead of directly attacking the file server’s availability, indirectly reduces productivity of other users on the server. In light of the large number of spam-related behavior on the Internet, this sort of nuisance attack is not entirely unrealistic. By addressing this sort of non-trivial attack, we had the opportunity to think as systems security engineers, whose jobs are no doubt affected as much by explicitly malicious behavior as by curious and generally misbehaving users.

