# Project Phase 4 - Threat Models
### Nathaniel Blake & James Huang
### CS 1653, Fall 2016

Phase 4 of the project introduced a few new threats that we have to address. For the first new threat, T5, we have to protect against message reorder, replay, and modification. In order to protect against message reorder and replay, we will be using sequence numbers - each message will sent/received will include a sequence number. If the sequence number is different from the number expected from the message, the message will become invalid. Further, to protect against message modification, all messages sent will include a SHA-256 HMAC to ensure integrity. The second new threat, T6, we have to protect against is file leakage. To ensure that leaked files will remain unreadable to unspecified users, each file will be encrypted. In order the read a file, a user needs to retrieve a “keychain” from the group server, which will contain the necessary key to decrypt and read the file. The group server will be maintaining the keys for the files. The final new threat we have to protect against is token theft, T7. To protect against stolen tokens, a new recipient field will be added to our tokens. The recipient file will contain the address and port number of the file server we are trying to communicate with. The token will then be signed by the group server to ensure authenticity (we are assuming the group server is universally trusted).

### A note on parameters
All Diffie-Hellman exchanges in the application shall use as parameters the values for DH group 15, as defined in RFC 3526. Also according to these recommendations, all DH exponents shall be 260 bits. This set of parameters provides an estimated strength of at least 128 bits, which as described in NIST SP 800-57 Pt. 1 Rev. 4, is predicted to remain secure through at least 2030. All symmetric key encryption shall be done with 128-bit AES keys and PKCS5 padding. Network transmissions shall be encrypted using CTR mode, while file encryption shall be done using CBC mode. Message digests shall be calculated using SHA-256, and HMACs will use SHA-256 and 128-bit keys.
 
## T5 Message Reorder, Replay, or Modification
In our current implementation, there is a threat of message reorder, replay, or  modification. Without a mechanism to determine whether a message has been reordered, replayed, or modified, our system is vulnerable. Message reorder would be problematic because it would allow an adversary to prevent us from getting the message we requested. Message replay can give an adversary the ability to impersonate a legitimate user on the system. Message modification allows an adversary to tamper with our intended message, which can lead to huge security risks. 


We first note that replay of messages outside an active session will fail by existing protocols, since session keys are used to encrypt connections between all clients and servers, and these keys are discarded as soon as either party disconnects. Thus, a replayed message would be indecipherable when there is no active session, or when a new session has begun with a new session key. Our current system is, however, susceptible to replay attacks within an active session, as well as to reordering of messages.


To alleviate these issues, we shall add to Envelope objects a sequence number. Each message exchanged from client to server will be numbered starting from 1 with the initiation of the handshake, and likewise each message from server to client will be numbered separately, starting at 1 with the initial handshake response. Each side will thus store two counters, one for next incoming sequence number and one for next outgoing sequence number, and will increment each counter by 1 for every message received and sent, respectively. In this way, all received messages will be expected to have a sequence number 1 greater than the previous message from the other party, and in the case of a mismatch, the session shall be terminated. This strictly increasing sequence protocol ensures that messages are received in order and that no previous messages can be replayed.


Further, all Envelope objects transmitted within the system outside of handshake exchanges shall include a SHA-256 HMAC using a session integrity key generated as an extension of the session confidentiality key generation. The HMAC shall be calculated over the serialized byte-array representation of the Envelope, since this is exactly what is transmitted over the wire. The receiver of an Envelope will then verify this HMAC before accepting an Envelope as valid. The use of an HMAC shall serve as proof of each message’s integrity, since only the client and server active in any given session have access to the session integrity key. In this way, any tampering done to the message in transit will cause the HMAC verification to fail. We thus defend the system against message tampering, to either the contents of the message or its header information, including the sequence number described above.


Adding a message sequence number to each message ensures that our messages are “fresh” and in order, since the client and server will only accept an incoming message if the sequence number is expected. Since each message will include an HMAC, we can also ensure that each message arrives unmodified by any party other than the sender. If HMAC verification fails or a message is out of sequence, the party receiving the invalid message shall close the connection, thus halting any reordering, replay, or modification behavior from occurring.


## T6 File Leakage
Since the file servers cannot be trusted to properly restrict file access in this phase, there is a possibility that any files stored on a file server will be leaked. If our files are unencrypted and leak to parties outside the group with which the file is meant to be shared, a core function of our application (group-based sharing) is effectively breached. Likewise, if a user is removed from a group but gains access to a file shared with the same group in the future, this former group member should not be able to view the contents of the file. To restrict file access to current and future members of a group at the time a file is shared, we shall enforce a policy that every file in the system is encrypted and hashed with a group- and phase-specific pair of confidentiality and integrity keys. The “phase” of a group corresponds to a time span during which a single pair of such keys are in use, and can be incremented at will by the group owner, for instance when one or more members are removed from a group. We make the assumption that when users are added to a group, they can view all files already shared with this group, as a matter of usefulness. On the other hand, any files uploaded or modified in a phase after that in which a user is removed from a group should be inaccessible to that user.


To enforce this policy, all files uploaded from clients to file servers shall be encrypted and signed using two 128-bit AES keys specific to the group with which the file is being shared and this group’s current phase. These per-group encryption and integrity keys shall be generated by the group server at the request of the group owner (first upon group creation, then by request to “rekey” the group by the group admin—for instance, after removing users from the group). The group server will store all group–key mappings, and each group key-pair will have a phase number that increments when the group is rekeyed. In this way, there will be one “keychain” per group that contains all keys used to encrypt and hash files for that group at any phase since the group’s creation (phase 0).


Once a user authenticates with the group server, the user can request a master keychain, in addition to their token, that contains the individual keychains for all groups in which they are a member. Upon joining a new group, a user shall be able to access keys from all previous phases for that group, allowing them access to already-shared files that have been previously encrypted. When a group owner rekeys a group, however, all current members will be required to retrieve the updated keychain from the group server before they are able to use the new-phase group key to encrypt and decrypt files. In this way, members removed from a group before a rekey will still be able to decrypt previously shared files (of which they could previously have made copied anyway) but will be unable to decrypt any files encrypted using the new-phase group key.


Last, we describe a method for embedding the key-phase metadata in files so that clients can properly decrypt files downloaded from file servers, as well as ensure the integrity of these files. When uploading a file to a file server or modifying an existing one, the user client shall proceed as follows: 1) encrypt the file using the most recent-phase key for the group with which the file is to be shared,, 2) prepend a 2-byte prefix to the file containing the phase number (in the range 0–65535) associated with the key used to encrypt the file, and 3) append a SHA-256 HMAC of the file to the file’s end. This HMAC shall be keyed with the corresponding group- and phase-specific 128-bit AES integrity key.


In this way, when a user client downloads a file from a file server, it can first check the integrity of the file by verifying the HMAC using the integrity key in its own keychain for the group, then it can read the phase number in order to select the proper key for decryption from the group keychain. If the file is leaked, only members holding access to the correct phase key for that group can read the file, and further, any modification to the file on the file server will be detected.


Our mechanisms to protect against file leakage and modification leverage a group-specific keychain managed by the group server. This keychain ensures that files can be safely stored on the file server because all messages stored on the file server are encrypted. Even if the file server is untrusted and leaks our files, an adversary would have no way to view the files without the correct keychain, which can only be obtained from the group server. Further, since our keys will have an associated phase number, users that are removed from a group will not be able to view files from the group after they are removed because their key would not contain the correct phase number. 


## T7 Token Theft
Because file servers are untrusted in this phase of the project and might attempt to steal user tokens, we implement a policy that limits the validity of a token to a single file server: each token request to the group server must also include the intended file server recipient address, which the group server will include in the signed fields of the token. In this way, a stolen token will only be valid on the file server from which it was stolen, thus preventing an adversary from setting up a malicious file server to steal user tokens and then use them to impersonate the other users on legitimate file servers.


The mechanism for this policy follows. To limit the validity of a user-transmitted token to a single server, the user shall, as part of requesting a token from the group server, submit the recipient file server’s address and port number. The group server will then store this information in a new field added to tokens for this phase of the project, before signing a hash of the token (including these new fields) as in previous phases. Each request made to a file server shall include a token with this recipient information and group server signature, and the file server must verify that it is the intended recipient of the token by checking the recipient field using the requesting user’s public key. If the signed address does not match that of the receiving server, the server shall disconnect the connected user.


Because the token is signed by the universally trusted group server, a match between the intended recipient field embedded in the token and the file server receiving the request implies that the token is being used on the intended file server. Any modification to the recipient field will invalidate the group server’s signature on the token, and an attempt to send the token to an unintended recipient file server will fail as long as the unintended recipient properly enforces this policy. (A file server that does not enforce this token policy is irrelevant to this particular threat; T6 protects against indiscriminate release of files by irresponsible file servers.)

## Conclusion

There is some interplay between between our proposed mechanisms. For example, our mechanisms for token theft and file leakage both protect against an untrusted file server. In addition, there is also an interplay between our mechanisms for T5. In T5, we use sequences numbers to protect against the threat. A sequence number that is not expected alerts the system of a message replay or reorder attack. We originally thought about using timestamps instead of sequence numbers but we decided against timestamps because syncronization would be difficult. The handshakes performed from Phase 3 of the project also provides us with a session key for encrypting each message after the handshake, thus protecting us from message replay/reorder/modification attacks since messages outside of the current session will be unreadable without the current session key. One area where we had a little trouble was generating a integrity key for HMAC in T5. The cause of our trouble was due to the fact that our handshake procedures for file and group intereactions are different so there was no good way to uniformly generate an integrity key. 

Further, our protocols still protect against all the threats in Phase 3 of the project. For T1, our protocols still include a handshake to authorize a user before a token can be issued. For T2, our group server still signs and encrypts our tokens to ensure integrity. For T3, our file server authentication is still performed before a connection can be established. Finally, T4 is still addressed due to the fact that all messages sent are encrypted using the session key established from the initial handshake performed.
