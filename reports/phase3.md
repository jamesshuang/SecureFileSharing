# Phase 3 Mechanisms and Protocols 

For Phase 3 of the project, there are several threats that we have to address. The first threat, T1, we have to protect against unauthorized token issuance. Specifically, we will use the Encrypted Key Exchange protocol to perform mutual authentication before a token can be issued to the user. In addition, this protocol will allow us to establish a shared secret with the group server - this shared secret will be used encrypt future exchanges. The shared secret will also help protect against the threat of passive monitoring and information leakage, T4. 


Another threat that we have to be aware of is token modification and forgery, T2. To protect against this threat, we will be signing of tokens to ensure that they are authentic and have not been modified. The final threat that we have to protect against is an unauthorized file server, T3. To ensure that the client is not communicating with an malicious server, the server will have to authenticate itself to the client.

## T1 Unauthorized Token Issuance 

The system shall not issue tokens to unauthenticated users. An adversary can, in the present implementation, impersonate any other user by merely requesting that user’s token from the group server. An adversary knowing the name of an administrative user would thus be able to perform any administrative group operations and ultimately to access any user’s files.

To fix this vulnerability, we will use mutual authentication according to the Encrypted Key Exchange protocol. As part of this mechanism, each user account shall have an associated password, initially chosen at the time of account creation by the administrator. (The first administrator account is created offline when running the Group Server; the rest utilize T4 to protect ) The group server will store a SHA-256 hash of each user’s password that acts as a shared secret with that user. Accordingly, when a user, Alice, requests a token in the future from the group server, she will send her username in cleartext as well as the start of a Diffie-Hellman exchange encrypted with the hash of her password. (This will be facilitated by our client application, which will prompt for Alice’s password, generate the hash, then “forget” the password.) The server will correspondingly follow through with the remainder of the EKE protocol, including the final mutual authentication using 128-bit challenges (since any two random 128-bit challenges are unlikely to be identical, thus preventing replay attacks from working without storing past secrets or requiring clock synchronization.) At the end of this Alice and the server will be mutually authenticated and will have a shared secret 128-bit key to use for symmetric encryption for further communications, as described in T4 below.

![T1 Protocol Diagram](https://github.com/blaken/cs1653-2016fa-jah245-nsb23/blob/master/reports/images/ph3-fig1.png)

(All Diffie-Hellman exchanges in the application shall use as parameters the values for DH group 15, as defined in RFC 3526. Also according to these recommendations, all DH exponents shall be 260 bits. This set of parameters provides an estimated strength of at least 128 bits, which as described in NIST SP 800-57 Pt. 1 Rev. 4, is predicted to remain secure through at least 2030.)

Because we trust the group server, we can be confident that the store of user–password-hash mappings will not be breached. Moreover, by the EKE protocol, neither the user password nor the hash of the user’s password will be transmitted across the network. Since the encrypted transmissions are the numbers of a Diffie-Hellman exchange, an adversary listener trying an offline dictionary attack would have extreme difficulty distinguishing the random-looking bit strings of the DH exchange as correct. Thus the group server can authenticate users before granting tokens, the user can authenticate with familiar password entry, and these and all future client–group-server communications will be secure against passive adversaries. This protocol is illustrated in Figure 1.

## T2 Token Modification/Forgery 

Tokens from the group server should in effect be immutable once granted to properly authenticated users. Without this protection, as in our current implementation, malicious users can modify their tokens and add themselves to any groups that they choose, including ADMIN. By doing so, any motivated user can view the files of any other users in the system.

In order to enforce this desired immutability, we will implement token signing. This mechanism will consist of requiring the group server to sign each granted token with its private key. The group server in this implementation shall store a 3072-bit RSA key-pair. As previously noted, this key length is recommended by NIST for cryptographic uses intended to remain secure through 2030. Upon authenticating a user, the group server will create a token storing the name of the group server, the subject the token is being issued to, and the groups to which the subject belongs—as in the current implementation. The group server will then sign the token using its private key and pass it on to the user.

We will add an additional byte array field to our token class in order to store this signature. To sign a token, the token issuer, subject, and (sorted) group fields will be concatenated together with a “+” character between each field and the resulting string hashed with SHA-256. When enforcing that usernames and groups are not allowed to contain the character “+”, inserting a “+” between each field ensures that the tokens [“server1”, “aliceADMIN”, {}] and  [“server1”, “alice”, {“ADMIN”}] do not produce the same signature. This hash will then be signed with the a provided key—in this case, the group server’s private key—and this signed hash will then be stored in the additional field in the token. 

![T2 Protocol Diagram](https://github.com/blaken/cs1653-2016fa-jah245-nsb23/blob/master/reports/images/ph3-fig2.png)

This signature process shall constitute the first of two methods of a TokenAuthority interface implemented by the Group and File Servers. (Implementing these in the servers ensures that the signing and verification process is independent of the Token objects, which can be modified by an adversary.) The second added method will perform verification of the signature stored in the Token object. As above, this method will concatenate the token fields except for the signature and then hash this string with SHA-256. The verification method will then decrypt the digital signature field of the Token with a provided key, in this case the group server’s public key. Last, this method will compare the newly formed hash against the signed hash previously stored in the Token and return the result of comparison. If the hashes match in this scenario, then the Token must have been created by the Group Server, which is the only entity with access to the Group Server private key, and further, it must not have been tampered with.

Since only the group server, which is trusted in the current threat model, knows its private key, no malicious users will be able to modify their tokens and equivalently sign them as the group server. When a file server wants to verify the legitimacy of a submitted user token, it will decrypt the token using the public key of the group server, which is available to all clients and servers in the system. If the user has tampered with the token, or if it has been corrupted in some other way, it will not decrypt cleanly, and the file server will reject the user request associated with the invalid token.

## T3 Unauthorized File Server 

In the case that an adversary runs a fake file server, an unknowing user could send revealing commands (for instance, ones revealing file names of previously uploaded files) or, in the worst case, upload files directly to the adversary’s machine. Certainly in our current implementation this is a potential threat; the user in no way authenticates file servers before interacting.

To ameliorate this issue, when a user requests to connect to a new file server, the server will send its public key to the user. The client application will convert this key to a fingerprint, that is, a SHA-256 hash of the key, and the user will have the opportunity to compare this fingerprint to the expected fingerprint. (This assumes that there is some other channel over which the user running the file server and the connecting user can communicate for this initialization step.) Once a user has accepted a new file server public key for the first time, the client application will save the accepted file server key on a per-user basis. In this way, when the user attempts to connect to this same file server in the future, the client application can compare the server’s presented public key with the stored, user-verified key.

![T3 Protocol Diagram](https://github.com/blaken/cs1653-2016fa-jah245-nsb23/blob/master/reports/images/ph3-fig3.png)

If the file server’s presented public key and that stored by the client application match, then the server must still be the originally verified file server. If they do not match, then the user will be prompted either to accept the new public key fingerprint as representing a valid change of public key (again, relying on another channel to verify this with the file server administrator) or to reject a connection to the unauthorized file server.

From this point, the client and server will perform a handshake to establish a shared secret as well as to authenticate the server to the user. This handshake protocol is based largely on the TLS protocol as described in RFC 5246. The user’s initial message to the server will include a random value that will be used later to generate the shared secret. The server will respond with its public key, as described above, and its own generated 28 random bytes (per 7.4.1 of RFC 5246). The user client will then generate a 48-byte premaster secret and send this to the file server encrypted with the file server’s public key. The file server authenticates by decrypting this message (since the server is the only one with access to its private key), and both sides calculate the session master secret, a 128-bit AES key generated using the HMAC-based pseudo-random function described in Section 8.1 of RFC 5246, with the pre-master secret used as secret and RA + RS used as seed. The file server will finalize the handshake by sending a message to the user that is encrypted with the session key, from which point this key will be used for all communications between user and file server. Note that this mechanism is resistant to reflection, replay, and man-in-the-middle attacks, since the random shared secret key also acts as a proof of freshness, and only Bob and the server will know the random secret, which is unlikely to be generated again in a future session due to its size. It does rely on a proper setup phase, however: just as SSH, it is vulnerable to file server impersonation if the user has no way to verify the server’s identity on the first connection.

## T4 Information Leakage via Passive Monitoring

Passive attackers should not have the ability to monitor the traffic being sent between the client and the server. Failure to protect against passive adversaries would allow listeners to gather information that would allow them impersonate a legitimate user on the network. In the current implementation, for instance, an adversary could steal a user token and use it to impersonate a legitimate user. Moreover, the contents of any files uploaded and downloaded are visible to anyone who can view the packets in transit, which further exposes potentially private data.


To protect against this class of passive attacks, all network communication among entities in the system shall be encrypted using symmetric keys. Specifically, all non-handshake communication between clients and servers in the system shall be encrypted using 128-bit AES in CTR mode. As described in T1, the EKE protocol includes the generation of a shared secret between the authenticating client and group server; all post-handshake messages between the client and the group server will be encrypted using this key. Likewise, as described in T3, the file server authentication protocol includes the generation of a shared secret between the client and the authenticating file server; all post-handshake messages between the client and the file server will be encrypted using this key. (See Figures 1 & 3.) These mechanisms are sufficient to prevent eavesdropping since they take place only between authenticated parties using secret keys of a size large enough to ensure secrecy. One weakness to mention is that the messages between users and file servers are not forward-secure; that is, if an adversary has recorded exchanges between these two parties and later gains access to the corresponding file server private key, it would be possible for the adversary to decrypt the previous communications.


## Conclusion

Our design process was a good learning experience. At first, our proposed protocols were not specific enough, which was problematic. For example, we did not mention anything about the size of our keys and challenges. We eventually were able to get everything figured out and have our proposal approved. 


Some of our proposal mechanisms helped protect against multiple threats. The shared secret established from our Handshake protocol in T1 helped us in T4 because the protocol created a shared secret between the client and the server. The shared secret also helped us protect against token modification and forgery - the signed token is always encrypted with the shared secret. There is also an interplay between T2 and T3 due to the use of public key cryptography. In T2, the private key of the group server was used to sign the token to ensure authenticity. In T3, the same key pairs were used for file server verification. There was a strong interplay between the mechanisms we used to protect against our threats. 

